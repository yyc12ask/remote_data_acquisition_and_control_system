# 远程数据采集控制网

## 项目描述

远程数据采集控制系统是通过CC2530模块进行数据采集，并且将数据传送至Linux系统中进行处理，用户通过web就可以远程查看数据并且控制设备和视频监控

## 涉及技术

MCU、C/C++、进程和线程、CGI、共享内存、消息队列、视频流服务器移植、信号量、互斥锁、zigbee、SQLite、Makefile

# 数据采集节点

## cc2530

- CC2530 单片机是一款完全兼容 8051 内核，同时支持 IEEE802.15.4 协议的无线射频单片机。
- CC2530微控制器采用QFN40封装，有40 个引脚。
- 其中，有21个数字I/O端口，其中P0和P1是8 位端口，P2仅有5位可以使用。
- 这21个端口均可以通过编程进行配置。
- 实际上，在P2端口的5个引脚中，有2个需要用作仿真，有2个需要用作晶振，在CC2530的开发中真正能够使用的只有17个引脚。
- 使用时需引入头文件“ioCC2530.h”

### USART

通用同步异步收发器（Universal Synchronous Asynchronous Receiverand Transmitter） 是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换。

**同步通信**
• 在发送数据信号的时候，会同时送出一根同步时钟信号， 用来同步发送方和接收方的数据采样频率。
**异步通信**
• 数据发送方和数据接收方没有同步时钟，只有数据信号线，只不
过发送端和接收端会按照协商好的协议（固定频率）来进行数据采样。

串行通信：利用一条传输线将资料一位位地顺序传送

并行通信：一排横队，齐头并进同时传输

**USB转UART**

使用CH340(南京沁恒)芯片

#### 帧格式

起始位：先发出一个逻辑“0”信号，表示传输字符的开始；
数据位：可以是5~8位逻辑“0”或“1”，如ASCII码（7位），扩展BCD码（8位），小端传输；
校验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验) ；
停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平；
空闲位：处于逻辑“1”状态，表示当前线路上没有资料传送。

### CC2530-USART

• CC2530 包括 2 个串行通信接口 USART0 与 USART1，
	• 每个串口包括两个模式：
		• UART（异步）模式、 SPI（同步）模式，
	• 两个 USART 具有同样的功能，可以设置在单独的 I/O 引脚。

### 寄存器

• 1. UxCSR：
• USARTx 控制状态寄存器
• 2. UxUCR：
• USARTx UART控制寄存器
• 3. UxGCR：
• USARTx 通用控制寄存器
• 4. UxBUF：
• USARTx UART接受/发送数据缓冲区
• 5. UxBAUD：
• USARTx 波特率控制寄存器

## zigbee

• ZigBee 是一种开放式的基于IEEE 802.15.4协定的无线个人局域网(Wireless PersonalArea Networks)标准。
• IEEE 802.15.4定义了物理层和媒体接入控制层
• 而ZigBee则定义了更高层如网路层及应用层等。

**ZigBee技术特点**

•
1. 低功耗
    由于ZigBee的传输速率低,发射功率仅为 1mW,而且采用了休眠模式功耗低，因此ZigBee设备非常省电。
    •
    据估算,ZigBee设备仅靠两节5号电池就可以维持长达6个月到2年右的使用时间。
    •
2. 低成本
    由于ZigBee模块的复杂度不高，ZigBee协议免专利费，再加之使的频段无需付费，所以它的成本较低。
    •
3. 时延短
    通信时延和从休眠状态激活的时延都非常短,典型的搜索设备时30ms,休眠激活的时延是15ms, 活动设备信道接入的时延为15ms。
    •
4. 网络容量大
    一个星型结构的ZigBee网络最多可以容纳254个从设备和一个主备, 一个区域内可以同时存在最多100个ZigBee网络,而且网络组成灵活。网状结构的ZigBee网络中可有65000多个点。
    •
5. 可靠
    采取了碰撞避免策略,同时为需要固定带宽的通信业务预留了专用隙,避开了发送数据的竞争和冲突。MAC层采用了完全确认的数据传输模式, 每个发送的数据包都必须等待接收方的确认息。如果传输过程中出现问题可进行重发。
    •
6. 安全
    ZigBee提供了基于循环冗余校验(CRC)的数据包完整性检查功能,持鉴权和认证, 采用了AES-128的加密算法,各个应用可以灵活确定其安全属性。

**Zigbee设备类型**

-  协调器

  • 它包含所有的网络信息，是3种设备中最复杂的，存储容量大、计算能力最强。
  • 它主要用于发送网络信标、建立一个网络、管理网络节点、存储网络节点信息、寻找一对节点间的路由信息并且不断的接收信息。
  • 一旦网络建立完成,这个协调器的作用就像路由器节点。

-  路由器

  它执行的功能包括允许其它设备加入这个网络，跳跃路由，辅助子树下电池供电终端的通信。

-  终端节点

  • 一个终端设备对于维护这个网络设备没有具体的责任,所以它可以睡眠和唤配，看它自己的选择。
  • 因此它能作为电池供电节点。

**ZigBee网络拓扑**

- 星型
- 簇状型
- 网状型

**ZigBee网状（MESH）网络**

- MESH网状网络拓扑结构的网络具有强大的功能，
  网络可以通过多级跳的方式来通信；
  该拓扑结构还可以组成极为复杂的网络；
  网络还具备自组织、自愈功能

### ZigBee网络建立-协调器建立一个新网络的流程

1） 检测协调器

- 节点必须具备两个条件：
  	1）具有ZigBee协调器功能，
  	2）没有加入到其它网络中。
- 任何不满足这两个条件的节点发起建立一个新网络的进程都会被网络层管理实体终止

2）信道扫描

- 信道扫描包括能量扫描和主动扫描两个过程。

3） 配置网络参数

- 网络层管理实体将为新网络选择一个PAN描述符，必须满足PAN描述符小于或等于0x3fff，不等于0xffff，并且在所选信道内是唯一的PAN描述符

4） 运行新网络

5） 允许设备加入网络

- 只有ZigBee协调器或路由器才能通过NLME_PERMIT_JOINING.request原语来设置节点处于允许设备加入网络的状态。

### ZigBee网络建立-节点加入网络

1） 通过MAC层关联加入网络

- • 1、子节点发起信道扫描
  • 2、 子节点存储各PAN信息
  • 3、 子节点选择PAN
  • 4、 子节点选择父节点
  • 5、 子节点请求MAC关联
  • 6、 父节点响应MAC关联
  • 7、 子节点响应连接成功
  • 8、 父节点响应连接成功

2） 通过与先前指定父节点连接加入网络

## Zigbee协议栈

• ZigBee 的协议分为两部分：
	• ZigBee 联盟定义了网络层、安全层和应用层技术规范，
	• IEEE802.15.4 定义了物理层和 MAC 层技术规范，

• ZigBee 协议栈就是将各个层定义的协议都集合在一起，以函数的形式实现，并给用户提供一些应用层 API,供用户调用。

• ZigBee 协议栈具有很多版本，不同厂商提供的 ZigBee协议栈有一定的区别。

### Zigbee协议栈使用

使用 ZigBee 协议栈进行开发的基本思路可以概括为如下三点：
• 1、用户对于 ZigBee 无线网络的开发就简化为应用层的 c 语言程序开发，不需要深入研究复杂的 ZigBee 协议栈；
• 2、 ZigBee 无线传感器网络中数据采集，只需用户在应用层加入传感器的读取函数即可；
• 3、如果考虑节能，可以根据数据采集周期进行定时，定时时间到就唤醒 ZigBee 的终端节点，终端节点唤醒后，自动采集传感器数据，然后将数据发送给路由器或者直接发给协调器。

## Zigbee协议栈函数

**AF_DataRequest函数**

- 无线发送函数
  • 向zigbee网络发送函数都调用该函数
  • 其中cID对应的就是函数
  GenericApp_MessageMSGCB()接收
  到的数据pkt->clusterId

**GenericApp_MessageMSGCB()**

- • 接收数据函数
  • 无线信道接收到的数据都会调用到该函数

**添加定时器功能**

我们希望终端节点可以定时上传传感器数据，这就需要定时器操作。

​	• 1. ZDO层更改网络状态后就启动定时器
​	• 2. 主任务处理函数
​		GenericApp_ProcessEvent()中，增加超时事件处理逻辑，上传传感器数据
​	• 3. 通过函数osal_start_timerEx()重新启动定时器

## 上位机与无线节点通信函数调用流程

1.上位机通过串口发送数据给协调器；
2.触发协调器串口回调函数`rxCB()`,通过`HalUARTRead()`从串口提取出数据；
3.协调器通过`AF_DataRequest()`将数据发送给网络中其他设备，通过`id:GENERICAPP_CLUSTERID`,表明改数据是协调器发送；
4.触发终端节点回调函数GenericApp_MessageMSGCB()，协调器id存放在`pkt->clusterId`中，发送的数据存放在`pkt->cmd.data`中；
5.终端节点可以采集传感器数据，发送数据在缓冲区`data`中，然后通过函数`AF_DataRequest()`发送数据，填充`id:GENERICAPP_CLUSTERID2`,表示数据是节点2发送；
6.触发协调器的回调函数`GenericApp_MessageMSGCB()`；
7.协调器提取出终端节点发送的数据`pkt->cmd.data`，通`HalUARTWrite()`发送给上位机。

# linux主控程序

## 链表的操作

使用到链表操作的位置：在zigbee数据采集线程和zigbee命令发送线程中使用到了链表的操作

链表的使用是为了防止发送命令太多，不让主线程一直等待串口发送数据（发送时需要延时，所以影响效率），而是先存到链表里面然后让其他线程来处理串口发送数据

- 链表都使用的是单链表

- 主要操作为插入节点和读取节点

  

  • 1.创建链表
  • linklist CreateEmptyLinklist()
  • 2.插入节点
  • int InsertLinknode (link_datatype x)
  • 3.提取一个节点
  • linklist GetLinknode (linklist h)

## I/O操作

使用到I/O操作的位置：

- 本项目中协调器通过串口与上位机 通信
- 串口设备被模拟成
  • /dev/ttyUSB0、/dev/ttyUSB1、 /dev/ttyS0、
  /dev/ttyS1
- 应用程序只需要通过系统调用操作设备文件
  • open()/read()/write()/close()…

**文件I/O介绍**
open()：调用open()函数可以打开或者创建一个文件。

close()：调用close()函数可以关闭一个打开的文件。

read()：调用read()函数可以从一个已打开的可读文件中读取数据。

write()：调用write()函数可以向一个已打开的可写文件中写入数据。

lseek()：调用 lseek()函数可以显示的定位一个已打开的文件，使用lseek后继续使用read和write将会定位到lseek定位的位置后继续读取或者写入

### 串口操作

串口操作结构体：termios（/usr/include/asm-generic/termbits.h）

tcgetattr函数：取得终端（fd）相关的参数，提供异步通讯接口

tcsetattr函数：设置与终端相关的参数

cfsetispeed和cfsetospeed函数：设置 termios 结构中存储的输入/出波特率为 speed

tcflush函数：清空终端未完成的输入/输出请求和数据

### 文件I/O进阶、错误码、库与系统调用

**文件描述符（0、1、2被占用）**
①顺序分配的非负整数
②内核用以标识一个特定进程正在访问的文件
③其他资源(socket、pipe等)的访问标识

文件描述符0、1、2的用途：标准输入、标准输出和标准出错

查看所有进程允许打开的最大 fd 数量
`cat /proc/sys/fs/file-max`
查看所有进程已经打开的 fd 数量以及允许的最大数量
`cat /proc/sys/fs/file-nr`
查看单个进程允许打开的最大 fd 数量.
`ulimit -n`
查看某个文件被哪些进程打开？【举例】
`sudo lsof filename`
查看某个进程打开了哪些文件？
`ls –l /proc/{PID}/fd` 可以查看某个进程打开了哪些文件

**两种IO**

1.不用缓存的I/O 
①通过文件描述符进行访问
②open()/read()/write()/lseek()/close()…

2.标准I/O（有缓冲区，当遇到换行符`\n`和缓冲区满了时会将数据推给硬件）
①通过FILE*进行访问
②printf()/fprintf()/fopen()/fread()/fwrite()/fseek()/fclose()…

**文件I/O – lseek()**

每个打开的文件都有一个与其相关的“当前文件位移量”，它是一个非负整数，用以度量从文件开始处计算的字节数。
通常，读/写操作都从当前文件位移量处开始，在读/写调用成功后，使位移量增加所读或者所写的字节数。
lseek()调用成功为新的文件位移量，失败返回-1，并设置errno。
lseek()只对常规文件有效，对socket、管道、FIFO等进行lseek()操作失败。
lseek()仅将当前文件的位移量记录在内核中，它并不引起任何I/O操作。
文件位移量可以大于文件的当前长度，在这种情况下，对该文件的写操作会延长文件，并形成空洞。

**错误码**

1. 全局错误码errno
① 在errno.h中定义，全局可见
② 错误值定义为“EXXX”形式，如EACCES
2. 处理规则
① 如果没有出错，则errno值不会被一个例程清除，即只有出错时，才需要
检查errno值
② 任何函数都不会将errno值设置为0，errno.h中定义了所有常数都不为0
3. 错误信息输出
① strerror() - 映射errno对应的错误信息
② perror() – 输出用户信息及errno对应的错误信息

**错误码**

1. 全局错误码errno
    ① 在errno.h中定义，全局可见
    ② 错误值定义为“EXXX”形式，如EACCES
2. 处理规则
    ① 如果没有出错，则errno值不会被一个例程清除，即只有出错时，才需要检查errno值
    ② 任何函数都不会将errno值设置为0，errno.h中定义了所有常数都不为0
3. 错误信息输出
    ① strerror() - 映射errno对应的错误信息
    ② perror() – 输出用户信息及errno对应的错误信息

打印错误信息时不适用printf而使用perror，因为perror除了打印要输出的信息外还可以打印出错的原因方便定位问题

**系统调用与库**

1. 系统调用
① 用户空间进程访问内核的接口
② 把用户从底层的硬件编程中解放出来
③ 极大的提高了系统的安全性
④ 使用户程序具有可移植性
2. 库函数
① 库函数为了实现某个功能而封装起来的API集合
② 提供统一的编程接口，更加便于应用程序的移植

## 进程

进程间的通信通过共享和内存、消息队列来传输

**C源码如何变成进程**

GCC编译过程的四个阶段：

1. 预处理
2. 编译
3. 汇编
4. 链接

c程序变成可执行程序后借助shell按照一定的规则进行加载在内存里变成一个进程对象，由操作系统进行调度

File Header：记录当前可执行文件/目标文件所有信息，多少段，文件大小，每个段的位置等

可执行程序加载到内存后，内存会分配一块堆栈，形参、局部变量在堆栈中，局部变量在函数运行中动态分配和释放，在elf文件中没有对应的段

使用malloc和free函数动态申请的空间在运行时在堆中分配，elf中没有对应的段

**ELF文件**

• ELF：Executable and Linkable Format.
• Linux系统上的可执行文件，.o文件，共享库，coredump文件都是ELF格式。
• ELF header在文件开始处描述了整个文件的组织，Section提供了目标文件的各项信息（如指令、数据、符号表、重定位信息等）
• section header table包含每一个section的入口，给出名字、大小等信息
• Program header table指出怎样创建进程映像，含有每个program header的入口
• elf中常见的段有如下几种：
代码段		text		存放函数指令
数据段		data		存放已初始化的全局变量和静态变量
只读数据段	rodata		存放只读常量或const关键字标识的全局变量
bss段		bss	存放未初始化的全局变量和静态变量，这些变量由于未初始化，所以没有必要在elf中为其分配空间。bss段的长度总为0
调试信息段	debug	存放调试信息
行号表		line		存放编译器代码行号和指令的duiing关系
字符串表	strtab		存储elf中存储的各种字符串
符号表		symtab		elf中到处的符号，用于链接

![image-20230709135551858](https://cdn.staticaly.com/gh/yyc12ask/typora_img@main/img/image-20230709135551858.png)

查看elf命令：readelf

**ELF到进程**

• 进程是一个程序被OS加载到RAM中执行后的一个完整的执行环境。
	• 正文段：
		• 存放被执行的机器指令。
	• 用户数据段：
		• 存放的是全局变量、常数以及动态数据分配的数据空间(如malloc函数取得的空间)等。
	• 堆栈段：
		• 存放的是函数的返回地址、函数的参数以及程序中的局部变量。

![image-20230709140306641](https://cdn.staticaly.com/gh/yyc12ask/typora_img@main/img/image-20230709140306641.png)

**进程和程序**

• 1. 进程是一个独立的可调度的任务
	• 进程是一个抽象实体。当系统在执行某个程序时，分配和释放的各种资源
• 2. 进程是一个程序的一次执行的过程
• 3. 进程和程序的区别
	• 程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何执行的概念
	• 进程是一个动态的概念，它是程序执行的过程，包括创
建、调度和消亡
• 4. 进程是程序执行和资源管理的最小单位 lwp

### 进程操作

**进程相关的几个命令**

• ps
	• 列出系统中当前运行的那些进程。
• top
	• 实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。
• kill
	• 向Linux系统的内核发送一个系统操作信号和某个程序的进程标识号，然后系统内核就可以对进程标识号指定的进程进行操作。
• nice/renice
	• 优先级操作
• bg
	• 将一个在后台暂停的命令，变成继续执行。
• fg
	• 将后台中的命令调至前台继续运行。

**进程运行状态**

• 运行态：
	• 此时进程或者正在运行，或者准备运行。
• 等待态：
	• 此时进程在等待一个事件的发生或某种系统资源。
		可中断
		不可中断
• 停止态：
	• 此时进程被中止。
• 死亡态：
	• 这是一个已终止的进程，但还在进程向量数组中占有一个task_struct结构。

通过fork函数创建进程

**进程的模式**

• 进程的执行模式分为用户模式和内核模式
• 用户态下只能访问用户空间
• 内核模式的代码可以无限制地访问所有处理器指令集以及全部内存和I/O空间。
• 用户模式的进程要享有内核模式特权，它必须通过系统调用向设备驱动程序或其他内核模式的代码发出请求。

内核会创建一个叫进程描述符task_struct的数据结构对象来管理进程，包括进程运行状态、优先级、进程号等

### Linux进程 系统调用
进程创建：fork()

进程的正常退出步骤:

- 子进程调用exit()函数退出
- 父进程调用wait()函数为子进程处理其他事情

如果进程不按照正确步骤来退出，就有可能产生僵尸进程和托孤进程

僵尸进程

- 子进程退出后，父进程没有调用wait()函数处理身后事，子进程变成僵尸进程

托孤进程

- 父进程比子进程先退出，子进程变为孤儿进程，Linux系统会把子进程托孤给1号进程(init进程)，这时1号进程就是这个子进程的父进程，init 进程会自动清理所有它继承的僵尸进程 。

**fork函数**

使用fork函数得到的子进程从父进程的继承了整个进程的地址空间，包括：
	• 进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。
• 子进程与父进程的区别在于：
	• 1、父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）
	• 2、各自的进程ID和父进程ID不同
	• 3、子进程的未决告警被清除；
	• 4、子进程的未决信号集设置为空集。

**vfork函数**

• 由于fork完整地拷贝了父进程的整个地址空间，因此执行速度是比较慢的。
• 为了提高效率，Unix系统设计者创建了vfork。
	• vfork也创建新进程，但不产生父进程的副本。
	• 它通过允许父子进程可访问相同物理内存从而伪装了对进程地址空间的真实拷贝，当子进程需要改变内存中数据时才拷贝父进程。
• 这就是著名的“写操作时拷贝”(copy-on-write)技术

**exec函数族**

fork函数可以用来创建子进程，但是子进程执行的是和父进程相同的程序或者关系很大的程序，单创建子进程往往是要让进程执行新的程序，这时候就用到了exec函数族。
当进程调用一种exec函数时，该进程用户空间的代码和数据会被新程序完全替代，然后从新程序的第一行代码开始执行，中间只要不出现错误就不会返回到原程序的代码，如果出现错误则返回到原程序中调用exec函数的下一行继续执行。
exec函数族并没有新建进程，因此进程的pid不变，它只是将原先进程的代码段数据段都替换成新进程的了

• exec函数族提供了一种在进程中启动另一个程序执行的方法。
• 它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段。
• 在执行完之后，原调用进程的内容除了进程号外，其他全部都被替换了。
• 可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。

**exec函数族-何时使用**

• 当进程认为自己不能再为系统和用户做出任何贡献了时就可以调用exec函数，让自己执行新的程序

• 如果某个进程想同时执行另一个程序，它就可以调用fork函数创建子进程，然后在子进程中调用任何一个exec函数。这样看起来就好像通过执行应用程序而产生了一个新进程一样

所需头文件
#include <unistd.h>
函数原型
int execl(const char *path, const char *arg, ...);
int execv(const char *path, char *const argv[]);
int execle(const char *path, const char *arg, ..., char *const envp[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execlp(const char *file, const char *arg, ...);
int execvp(const char *file, char *const argv[]);
函数返回值
-1：出错

**exec函数族使用区别**

• 可执行文件查找方式
	• 表中的前四个函数的查找方式都是指定完整的文件目录路径，
	• 而最后两个函数(以p结尾的函数)可以只给出文件名，系统会自动从环境变量“$PATH”所包含的路径中进行查找。

• 参数表传递方式
	• 两种方式： 逐个列举或是将所有参数通过指针数组传递
	• 以函数名的第五位字母来区分，
		• 字母为“l”(list)的表示逐个列举的方式；
		• 字母为“v”(vertor)的表示将所有参数构造成指针数组传递，其语法为	char *const argv[]

• 环境变量的使用
	• exec函数族可以默认使用系统的环境变量，也可以传入指定的环境变量。
	• 这里，以“e”(Enviromen)结尾的两个函数execle、execve就可以在envp[]中传递当前进程所使用的环境变量

**_exit和exit的区别**

• _exit() ：
	• 直接使进程终止运行，清除其使用的内存空间，并销毁其在内核中的各种数据结构；
• exit()
	• 在这些基础上作了一些包装，在执行退出之前加了若干道工序。
	• exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件，就是图中的"清理I/O缓冲"一项。

**wait和waitpid**

• wait函数
	• 调用该函数使进程阻塞，直到任一个子进程结束或者是该进程接收到了一个信号为止。如果该进程没有子进程或者其子进程已经结束，wait函数会立即返回。
• waitpid函数
	• 功能和wait函数类似。可以指定等待某个子进程结束以及等待的方式（阻塞或非阻塞）

本项目没使用waitpid

### 进程间通信

常用的进程间通信方式

• 传统的进程间通信方式
	无名管道(pipe)、有名管道(fifo)和信号(signal)

• System V IPC对象
	共享内存(share memory)、消息队列(message queue)和信号灯(semaphore)

• BSD
	套接字(socket)，不同计算机之间进程间的通信机制

主控进程通过<font color='orange'>共享内存</font>将环境数据发送给cgi进程，一些其他进程发送命令是通过<font color='orange'>消息队列</font>，浏览器和boa进程通过<font color='orange'>网络http协议</font>（归根结底使用了套接字socket）。浏览器通过网络找到视频流服务器（MJPG-streamer）接收数据

浏览器也可以发送命令给摄像头，通过网络发送消息给boa，boa发送消息到消息队列，主线程接收到消息将命令转发给camera线程，camera通过写入字符设备文件来实现摄像头拍照

**共享内存**

• 共享内存是一种最为高效的进程间通信方式，进程可以直接读写内存，而不需要任何数据的拷贝
• 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间
• 进程就可以直接读写这一内存区而不需要进行数据的拷贝，从而大大提高的效率。
• 由于多个进程共享一段内存，因此也需要依靠某种同步机制，如互斥锁和信号量等

**共享内存在该项目中使用**

• 从串口读取的zigbee网络环境数据要发送给web页面或者APP，必须满足：
	• 1.所有的其他进程都可以定时从”某块内存”读取数据
	• 2.有新的数据更新时，可以很方便的将数据写入到”某块内存”
	• 3.读取的数据不需要清除原有数据，写入的数据要更新到这块内存

• 共享内存的使用包括如下步骤：
	• 1.创建/打开共享内存
	• 2.映射共享内存，即把指定的共享内存映射到进程的地址空间用于访问
	• 3.撤销共享内存映射
	• 4.删除共享内存对象

共享内存函数shmget:该函数用来创建和获取共享内存
共享内存函数shmat:创建完共享内存后得到的共享内存标识符，还不能被任何进程访问。使用shmat()函数，则可将共享内存attach到调用进程的进程地址空间。
共享内存函数shmdt:该函数用于将共享内存从当前进程中分离。该函数不会删除共享内存段，而只是使得当前进程不可在访问该共享内存。
共享内存函数shmctl:该函数与信号量的semctl()函数作用类似，用来控制共享内存

**消息队列**

• 消息队列是IPC对象的一种
• 消息队列由消息队列ID来唯一标识
• 消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。
• 消息队列可以按照类型来发送/接收消息

**消息队列在该项目中使用**

• 从web页面或者APP下发的命令，最终要通过串口发送给zigbee网络的终端节点，以控制各种外设，需要考虑以下问题：

1. 所有的命令不能丢失(连续点击页面按钮)
2. 命令需要按照一定顺序排列
3. zigbee网络可能延时相比较有点大，不能发送太快

消息队列函数-msgget:得到消息队列标识符或创建一个消息队列对象
消息队列函数-msgsnd:将消息写入到消息队列
消息队列函数-msgrcv:从消息队列读取消息
消息队列函数-msgctl:获取和设置消息队列的属性

**临界资源**

• 一次只允许一个进程使用的资源称为临界资源；
	• 临界资源并不全是硬件或是软件，而是两者都能作为临界资源。
	• 比如硬件的有：
		• 打印机、磁带机等；
	• 软件有：
		• 消息缓冲队列、变量、数组、缓冲区等；

• 临界区（critical region）
	• 访问共享变量的程序代码段称为临界区，也称为临界段（criticalsection）;
• 进程互斥
	• 两个或两个以上的进程不能同时进入关于同一组共享变量的临界区，否可可能会发生与时间有关的错误，这种现象称为进程互斥；

**本项目中的临界资源**

本项目临界资源有：链表、摄像头、串口、共享内存、消息队列、数据库

比如共享内存需要互斥访问
	• 有进程在访问时，其他进程不能访问
	• 信号量初始值为1

**信号灯**

• 信号灯(semaphore)，也叫信号量。它是不同进程间或一个给定进程内部不同线程间同步的机制。
• 信号灯种类：
	posix有名信号灯(可用于线程、进程同步)
	posix基于内存的信号灯(无名信号灯)
	System V信号灯(IPC对象)
本篇主要讲System V 信号灯

System V 信号灯

• System V的信号灯是一个或者多个信号灯的一个集合。其中的每一个都是单独的计数信号灯。
• 而Posix信号灯指的是单个计数信号灯
• System V 信号灯由内核维护

• 二值信号灯：
	• 值为0或1。与互斥锁类似，资源可用时值为1，不可用时值为0。
• 计数信号灯：
	• 值在0到n之间。用来统计资源，其值代表可用资源数

• 通常把信号量操作抽象成PV操作
	• P：等待操作是等待信号灯的值变为大于0，然后将其减1；
	• V：释放操作则相反，用来唤醒等待资源的进程或者线程

sem函数-semget：创建一个新信号量或取得一个已有信号量

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semget(key_t key, int nsems, int semflg); 
创建信号量;创建成功返回信号量集ID，失败返回-1
参数：
    key :键值
   nsems: 信号量集个数
   semflg：获取|创建IPC_CREAT|0666 


```

sem函数-semctl：初始化信号量

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semctl(int semid, int semnum, int cmd, ...); 
 //初始化信号量
 参数：
   1、 semid ： 信号量集id
   2、semnum：操作第几个信号量集
   3、cmd    ：初始化，SETVAL 设置信号量的值
   4、  ...   ：设置SETVAL需要配置第四个参数，第四个参数是一个联合体
   union semun {
               int              val;    /* Value for SETVAL */
               struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */
               unsigned short  *array;  /* Array for GETALL, SETALL */
               struct seminfo  *__buf;  /* Buffer for IPC_INFO
                                           (Linux-specific) */
};

```

sem函数-semop：完成对信号量的P操作或V操作

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semop(int semid, struct sembuf *sops, unsigned nsops); 
//对信号量操作
 对信号量操作，改变信号量的值，成功返回0，失败返回-1
 参数：
  semid ：信号量集id 
  *sops ：配置信号量集 （结构体）
  nsops ：配置信号量集的个数

 sops[n]结构体如下：
 n为信号量集个数
struct sembuf sops[2];
           int semid;

           /* Code to set semid omitted */
     配置以下三个参数：
     sops[0].sem_num = 0; 第几个信号量       /* Operate on semaphore 0 */
     sops[0].sem_op = 0; 操作信号量赋值       /* Wait for value to equal 0 */
     sops[0].sem_flg = SEM_UNDO （设置为阻塞）


     sops[1].sem_num = 0;        /* Operate on semaphore 0 */
     sops[1].sem_op = 1;         /* Increment value by one */
     sops[1].sem_flg = 0


```



函数使用

初始化：

<img src="https://cdn.staticaly.com/gh/yyc12ask/typora_img@main/img/image-20230710162950400.png" alt="image-20230710162950400" style="zoom: 80%;" />

完成对信号量的P/V操作：

<img src="https://cdn.staticaly.com/gh/yyc12ask/typora_img@main/img/image-20230710163032238.png" alt="image-20230710163032238" style="zoom:80%;" />

<img src="https://cdn.staticaly.com/gh/yyc12ask/typora_img@main/img/image-20230710163040567.png" alt="image-20230710163040567" style="zoom:80%;" />

**本项目中信号的使用场景**

有些资源能自动回收，而有些资源需要去释放资源

• 当我们按下ctrl+c终止主控程序时，希望能够实现如下操作：
	• 1.进程退出
	• 2.释放所有申请的资源
		• 互斥锁、条件变量、消息队列、共享内存、信号量、线程、设备文件描述符(摄像头、串口)

按下ctrl+c会向进程发送SIGINT信号，可以给信号注册一个处理函数，函数自动释放资源调用exit退出即可。

**信号通信**

• 信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式
• 信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。
• 如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它；
• 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程

• 用户进程对信号的响应方式：
	• 忽略信号：
		• 对信号不做任何处理，但是有两个信号不能忽略：即SIGKILLSIGSTOP。
	• 捕捉信号：
		• 定义信号处理函数，当信号发生时，执行相应的处理函数。
	• 执行缺省操作：
		• Linux对每种信号都规定了默认操作

信号发生后，应用程序暂停当前程序执行，保存当前上下文，跳转到信号处理函数来处理信号指令，信号处理玩后恢复进程上下文，恢复完成后从原来的指令的下一条指令开始执行（类似中断，但中断复杂很多）

![image-20230710171238906](https://cdn.staticaly.com/gh/yyc12ask/typora_img@main/img/image-20230710171238906.png)

用户进程对信号的处理方式：

- 忽略:进程当信号从来没有发生过
- 捕获:进程会调用相应的处理函数，进行相应的处理
- 默认:使用系统默认处理方式来处理信号

进程可以设定对信号的相应方式
• 信号处理的主要方法有两种
	• 使用简单的signal()函数
	• 使用信号集函数族sigaction
该项目只使用了signal

信号设置函数signal()：
• 使用signal函数处理时，需指定要处理的信号和处理函数
• 使用简单、易于理解

该函数的signum：指定信号

handler：可以设置以下相关标志
1、SIG_IGN：忽略该信号。
2、SIG_DFL：采用系统默认方式处理信号。
3、自定义的信号处理函数指针

函数返回值
成功：设置之前的信号处理方式
出错：-1

**信号发送**

• kill()和raise()
	• kill函数同读者熟知的kill系统命令一样，可以发送信号给进程或进程组(实际上，kill系统命令只是kill函数的一个用户接口)。
	• kill –l 命令查看系统支持的信号列表
	• Raise 函数允许进程向自己发送信号

**信号类型**

SIGINT：该信号在用户键入INTR字符(通常是Ctrl-C)时发出，终端驱动程序发送此信号并送到前台进程中的每一个进程。
默认操作：终止
SIGQUIT：该信号和SIGINT类似，但由QUIT字符(通常是Ctrl-\)来控制。
默认操作：终止
SIGSTOP：该信号用于暂停一个进程，且不能被阻塞、处理或忽略。
默认操作：暂停进程
SIGTSTP：该信号用于暂停交互进程，用户可键入SUSP字符(通常是Ctrl-Z)发出这个信号。
默认操作：暂停进程

进程间通讯方式比较
• signal信号: 唯一的异步通信方式
• msg消息队列：常用于cs模式中， 按消息类型访问 ，可有优先级
• shm共享内存：效率最高(直接访问内存) ，需要同步、互斥机制
• sem信号量：配合共享内存使用，用以实现同步和互斥
• pipe管道: 具有亲缘关系的进程间，单工，数据在内存中
• fifo有名管道: 可用于任意进程间，双工，有文件名，数据在内存

## 线程

**本项目使用场景**

• 对于多个阻塞任务，必须使用多进程/多线程
• 所有的临界资源的操作都必须互斥:
	• 共享内存、消息队列、链表、串口、摄像头、数据库等
• 线程之间同步机制主要用的：
	• 互斥锁、条件变量

**线程基础**

• 线程有时被称为轻量级进程(LightweightProcess，LWP），是程序执行流的最小单元。
• 线程是进程中的一个实体，是被系统独立调度和分派的基本单位，
• 线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。

引入线程前，进程是资源分配的基本单位，也是调度的基本单位
引入线程后，进程是资源分配的基本单位，线程是调度的基本单位

线程
• 允许程序执行不止一个任务的机制
• 并行执行
• 受操作系统异步调度，是操作系统调度的最小单元，
• 进程内的不同线程执行是同一程序的不同部分
主线程
• 线程可由进程创建，操作系统在创建进程时会创建一个主线程，程序main()函数是主线程的入口。

• 1. 由于进程的地址空间是私有的，因此在进程间上下文切换时，系统开销比较大，在同一个进程中创建的线程共享该进程的地址空间，
• 2.每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。
• 3. 线程也有就绪、阻塞和运行三种基本状态。
• 4. Linux里同样用task_struct来描述一个线程。线程和进程都参与统一的调度
• 5. 多线程通过第三方的线程库来实现 New POSIX ThreadLibrary （NPTL）



**多线程优点**

• 1. 经济实惠
	• 分配的资源少、线程切换比进程切换快、维护线程的开销小
• 2 资源共享
	• 线程共享它们所属进程的存储器和资源。
• 3 提高了响应速度
	• 允许程序在它的一部分被阻塞或正在执行一个冗长 的操作时持续运行
• 4 提高了多处理机体系结构的利用率
	• 在多CPU机器中，多线程提高了并发性

一个进程中的多个线程共享以下资源：
• 可执行的指令
• 静态数据
• 进程中打开的文件描述符
• 信号处理函数
• 当前工作目录
• 用户ID
• 用户组ID

每个线程私有的资源如下
• 线程ID (TID)
• PC(程序计数器)和相关寄存器
• 堆栈
• 局部变量
• 返回地址
• 错误号 (errno)
• 信号掩码和优先级
• 执行状态和属性

### 多线程编程

多线程函数-pthread_create
	创建线程
多线程函数-pthread_join
	用于挂起当前线程（调用pthread_join的线程），直到thread指定的线程终止运行为止，当前线程才继续执行。（thread：线程标识符）
多线程函数-pthread_exit、pthread_cancel
	调用pthread_exit线程退出（return返回，线程也会退出）
	调用该函数的执行流可以取消其它线程，但是需要知道其它线程的线程标识符，也可以执行流自己取消自己，传入自己的线程标识符。

**线程查看**

• ps –efL
	• UID：用户ID
	• PID：process id 进程id
	• PPID: parent process id 父进程id
	• LWP：表示这是个线程；要么是主线程(进程)，要么是线程
	• NLWP: num of light weight process 轻量级进程数量，即线程数量
	• STIME: start time 启动时间TIME: 占用的CPU总时间
	• TTY：该进程是在哪个终端运行的
	• CMD：进程的启动命令
• ps -ef f
	• 用树形显示进程和线程

### 多线程-互斥锁

• 互斥锁主要用来保护临界资源
• 每个临界资源都由一个互斥锁来保护，任何时刻最多只能有一个线程获得互斥锁才能能访问该资源
• 使用规则:
	• 线程必须先获得互斥锁才能访问临界资源，访问完资源后释放该锁。
	• 如果无法获得锁，线程会阻塞直到获得锁为止

`int pthread_mutex_init()`：初始化互斥锁
`int pthread_mutex_lock()`：申请互斥锁
`int pthread_mutex_unlock()`：释放互斥锁

### 多线程-条件变量

• 条件变量是利用线程间共享的全局变量进行同步的一种机制。
• 主要包括两个动作：
	• 一个线程等待“条件变量的条件成立”而挂起；
	• 另一个线程使“条件成立”（给出条件成立信号）并唤醒挂起线程。
• 为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。对条件的测试是在互斥锁（互斥）的保护下进行的。

**本项目使用场景**

• 主控进程的主线程通过阻塞方式从消息队列中提取出指令后需要发送给camera控制线程和zigbee命令发送线程，后面2者必须阻塞直到主线程发送数据
• 共享内存数据刷新线程也必须阻塞等待Zigbee数据采集线程通过串口读取到的数据

`int pthread_cond_init()`：条件变量初始化（创建）
`int pthread_cond_destroy()`：条件变量注销
`int pthread_cond_wait()`：条件变量等待
`int pthread_cond_signal()`：条件变量唤醒

互斥锁和条件变量经常联合使用来完成同步功能

## 摄像头

**常见图像格式**

• 1 RGB格式
	• 传统的红绿蓝格式，比如RGB565，RGB888，其16-bit数据格式为5-bit R + 6-bit G + 5-bit B。G多一位，原因是人眼对绿色比较敏感
• 2 YUV格式
	• YUV是指亮度参量和色度参量分开表示的像素格式，而这样分开的好处就是不但可以避免相互干扰，还可以降低色度的采样率而不会对图像质量影响太大
• 3 RAW data格式
	• RAW图像就是CMOS或者CCD图像感应器将捕捉到的光源信号转化为数字信号的原始数据。【dataRaw data（Raw RGB）经过彩色插值就变成RGB】

这里使用的摄像头是YUV格式

**图像压缩方式**
• JPEG/M-JPEG
• H.261/H.263
• MPEG
• H.264
• H.265

这里是JPEG

**mjpg-streamer移植**

• mjpg-streamer：网络摄像机程序

• MJPG-streamer是一个优秀的开源project，它可以通过HTTP的方式访问linux上面的兼容摄像头，从而做到远程视频传输的效果。
• MJPG-streamer从webcam摄像头采集图像，把他们以流的形式通过基于ip的网络传输到Windows的浏览器(如Firehox，Cambozola，VLC播放器) 移动设备或者其他拥有浏览器的移动设备。

**mjpg-streamer支持单拍、连拍**

• mjpg_stream 中 output-file.so 只实现了连续拍照的功能，没有实现单拍或 连拍几张的功能
• 修改以下文件:
	• work/camera/mjpg-streamer/mjpg-streamer/plugins/output_file/output_file.c

## 主控程序

data_global.c：存放线程用到的同步互斥的资源

lib文件夹：下面存放支持ARM架构的库

link_list.c和link_list.h文件：链表操作相关

main.c：互斥锁初始化、条件变量初始化

pthread_camera.c：对应camrea控制线程，负责从主控中读取对应的命令，然后将命令设置到摄像头中

pthread_main.c：主线程，负责从消息队列中提取数据，然后将命令收发给其他线程

pthread_refresh.c：负责将链表里面的信息读取出来，重新加工下将数据发送到共享内存里

pthread_uart_send.c：zigbee命令发送线程，从链表里读取命令，然后将命令发送给串口

pthread_zigbee_rcv.c：从串口读取环境信息，并将信息填充到链表里，同时填充完通知共享内存刷新线程读取新的数据

sem.h：信号量相关的操作,初始化，p操作，v操作

test.c：测试消息队列

uart_cache.c和uart_cache.h文件：主控程序将zigbee命令发送给zigbee命令发送线程的链表操作

### 主控程序功能详细说明

- camera线程、zigbee线程、链表是临界资源需要申请锁
- 主线程通过switch来选择将数据发送给camera控制线程还是将数据发送到zigbee发送命令线程
- `pthread_uart_send.c`zigbee数据采集线程初始化串口，从串口读取的数据有可能不是完整的从结构体头部读取，这里使用if语句判断标识位`st:`,接收完数据后将数据加入到链表中，最后唤醒`pthread_refresh（）`共享内存数据刷新线程
- 在共享内存数据刷新线程中，共享内存区申请大小要够，这里申请的大小为1024，然后等待数据采集线程唤醒此线程；然后遍历链表将里面所有数据读取完，这里需要申请互斥锁，数据读取后重新填充到env_info结构体并最后填充到共享内存中；共享内存是进程之间的，所以用信号量来控制互斥访问，约定了所有访问共享内存的进程都必须先申请信号量，互斥锁是线程之间的
  - 一般多线程同步使用了互斥锁，互斥锁是常见同步方法中最简单最有效的方法，核心思想是：有线程访问进程空间中的公共资源时，该线程执行“加锁”操作，阻止其他线程访问，访问完成之后，该线程负责完成“解锁”操作，将资源让给其它线程，当有多个线程想访问资源时，谁最先完成“加锁”操作，谁就最先访问资源。多个线程想访问“加锁”状态下的公共资源时，他们只能等待资源“解锁”，所有的线程会排成一个等待队列。资源解锁后，操作系统会唤醒等待队列中的所有线程，第一个访问资源的线程会率先将资源“锁”起来，其他线程则继续等待。
  - 对于多个进程共享的共享内存来说，惟一可靠的互斥机制，就是带SEM_UNDO的system V信号量。原因是：某个进程在持有锁期间意外退出，所持有的锁还没有来得及释放，这会造成所有等待（p操作）这个锁的进程/线程死锁。所以不建议使用POSIX信号量或者互斥锁。
  - 对于同步机制，可以使用POSIX匿名信号量。
  - 对于异步通知机制，可以使用FIFO或者eventfd

程序启动时将会创建主线程、camera线程、共享内存数据刷新线程、zigbee命令发送线程、zigbee命令采集线程。camera线程和zigbee命令发送线程被条件变量等待（`pthread_cond_wait()`），直到主线程发送数据给这两个线程。zigbee数据采集线程循环等待串口数据的到来，一旦串口发送了数据就会接收从`st：`开始的数据，添加互斥锁和链表互斥并将数据加入到链表中。共享内存数据刷新线程被条件变量等待zigbee采集线程的数据，从链表中获取数据并使用信号量互斥访问共享内存将数据存放到共享内存中。

### 数据流

命令发送时在结构体msg中

- 填充命令类型给msgtype
- 内容给text[0]（拍照数量、开关闭合等）
- 主线程提取内容填充到链表节点中的data，并插入链表
- Zigbee命令发送线程丛链表提取出命令填充到全局变量dev_uart_mask并发送给协调器

数据接收

- 根据节点编号将数据写到共享内存对应的那块内存里

# web端

## SQLite

• 1. 零配置一无需安装和管理配置；
• 2. 储存在单一磁盘文件中的一个完整的数据库；
• 3. 数据库文件可以在不同字节顺序的机器间自由共享；
• 4. 支持数据库大小至2TB；
• 5. 足够小，全部源码大致3万行c代码，250KB；
• 6. 比目前流行的大多数数据库对数据的操作要快。

**主要数据类型**

数据类型 NULL：表示该值为NULL值。
INTEGER：无符号整型值。
REAL：浮点值。
TEXT：文本字符串，存储使用的编码方式为UTF-8、UTF-16BE、UTF-16LE。
BLOB：二进制大对象数据，可用于存储图像和其他二进制数据。1表示true，0表示false。

**约束**

非空 NOT NULL：有一些字段我们可能一时不知到该填些什么，同时它也没设定默认值， 当添加数据时，我们把这样的字段空着不填，系统认为他是 NULL 值。 但是还有另外一类字段，必须被填上数据，如果不填，系统就会报错。 这样的字段被称为 NOT NULL 非空字段。

唯一 UNIQUE：除了主列以为，还有一些列也不能有重复值。

主键 PRIMARY KEY： 一般是整数或者字符串，只要保证唯一就行。 在 SQLite 中，主键如果是整数类型，该列的值可以自动增长。

默认值 DEFAULT：有一些特别的字段列，在每一条记录中，他的值基本上都是一样的。只是在个别情况下才改为别的值，这样的字段列我们可以给他设一个默认值。

条件检查 CHECK：某些值必须符合一定的条件才允许存入，这是就需要用到这个 CHECK 约束。

外键 FOREIGN KEY：用于指定一个表中的值也出现在另一个表中。

**相关操作语句**

• 创建表
• CREATE TABLE IF NOT EXISTS user(name text NOT NULL,password textNOT NULL);
• 插入
• insert into user values(‘root',‘123456');
• 查找
• select * from user where name= 'root' and password= '123456';
• 修改
• Update user where name= 'root‘;

**Sqlite C编程接口**

sqlite3_open：打开sqlite数据库
sqlite3_close：关闭sqlite数据库
sqlite3_errmsg：打印错误信息
sqlite3_exec：执行SQL增删改查操作
sqlite3_get_table：执行SQL操作

## boa

BOA是一款非常小巧的Web服务器，源代码开放、性能优秀、支持CGI通用网关接口技术，特别适合应用在嵌入式系统中。
• BOA服务器主要功能是在互联嵌入式设备之间进行信息交互，达到通过网络对嵌入式设备进行监控，并将反馈信息自动上传给主控设备的目的。
• 它是基于HTTP超文本传输协议的，Web网页是Web服务最基本的传输单元。

## CGI

• CGI：通用网关接口（Common Gateway Interface）是用来规定Web Server和应用程序直接进行数据数据传输的协议。
• CGI 应用程序是放置在服务器上的一段可执行程序。
	• 能与浏览器进行交互，还可通过数据API与数据库服务器等外部数据源进行通信，从数据库服务器中获取数据。
• 几乎所有服务器都支持CGI
• 可用任何语言编写CGI：
	• C、C ++、Java、VB 和Delphi 等。

**CGI的运行过程**

•1. 用户访问Web应用，发起一个HTTP请求，Web服务受到该请求；
•2. HTTP服务器将请求数据从HTTP请求中解析出来，根据请求的URL创建一个新的CGI进程，并通过环境变量和标准输入传入到CGI进程中；
•3. CGI进程根据请求进行逻辑处理，连接其他服务请求数据或者从DB获取数据或者只是单纯的进行逻辑运算；
•4. CGI进程将处理的结果写入到标准输出中；
•5. Web服务器从标准输出中读取相应结果，并返回给用户；
•6. Web服务器关闭CGI进程。

**CGIC 常用的API、结构体**

用CGIC写的源码其主函数是cgiMain()，而不是通常的main。

